const fs = require('fs');
const path = require('path');
const { Client } = require('minio');
const mysql = require('mysql2/promise');
require('dotenv').config();

// MinIO configuration
const minioClient = new Client({
  endPoint: 'localhost',
  port: 9000,
  useSSL: false,
  accessKey: 'minioadmin',
  secretKey: 'minioadmin',
});

const bucketName = 'pgdesign-assets';

// MySQL configuration  
const dbConfig = {
  host: 'localhost',
  port: 3306,
  user: 'pgdesign',
  password: 'pgdesignpassword',
  database: 'pgdesign_dev'
};

// Mock data based on projectPageService.ts
const mockData = {
  aboutProject: {
    title: 'D·ª± √°n',
    subtitle: 'PG DESIGN',
    isActive: true
  },
  statsSection: {
    mainHeadline: 'TH√ÄNH T·ª∞U C·ª¶A CH√öNG T√îI',
    subHeadline: 'Nh·ªØng con s·ªë ·∫•n t∆∞·ª£ng',
    description: 'V·ªõi nhi·ªÅu nƒÉm kinh nghi·ªám trong lƒ©nh v·ª±c thi·∫øt k·∫ø ki·∫øn tr√∫c v√† n·ªôi th·∫•t, ch√∫ng t√¥i t·ª± h√†o mang ƒë·∫øn nh·ªØng gi·∫£i ph√°p t·ªëi ∆∞u cho m·ªçi kh√¥ng gian s·ªëng.',
    statsItems: [
      {
        iconName: 'experience-icon',
        iconUrl: 'experience-icon.svg',
        targetValue: 5,
        label: 'Kinh nghi·ªám',
        suffix: '+ nƒÉm',
        description: 'Kinh nghi·ªám',
        category: 'experience',
        displayOrder: 0
      },
      {
        iconName: 'customer-icon',
        iconUrl: 'customer-icon.svg',
        targetValue: 500,
        label: 'Kh√°ch h√†ng',
        suffix: '+',
        description: 'Tin t∆∞·ªüng & h√†i l√≤ng',
        category: 'customers',
        displayOrder: 1
      },
      {
        iconName: 'design-icon',
        iconUrl: 'design-icon.svg',
        targetValue: 450,
        label: 'D·ª± √°n',
        suffix: '+',
        description: 'Thi·∫øt k·∫ø ho√†n th√†nh',
        category: 'projects',
        displayOrder: 2
      },
      {
        iconName: 'building-icon',
        iconUrl: 'building-icon.svg',
        targetValue: 98,
        label: 'Ch·∫•t l∆∞·ª£ng',
        suffix: '%',
        description: 'Cam k·∫øt ho√†n h·∫£o',
        category: 'quality',
        displayOrder: 3
      }
    ]
  },
  projectCategories: {
    mainTitle: 'DANH M·ª§C D·ª∞ √ÅN',
    subtitle: 'KH√ÅM PH√Å C√ÅC LO·∫†I H√åNH THI·∫æT K·∫æ',
    description: 'T·ª´ nh·ªØng cƒÉn nh√† ph·ªë hi·ªán ƒë·∫°i ƒë·∫øn nh·ªØng bi·ªát th·ª± sang tr·ªçng, t·ª´ kh√¥ng gian n·ªôi th·∫•t tinh t·∫ø ƒë·∫øn nh·ªØng ng√¥i nh√† v∆∞·ªùn xanh m√°t - ch√∫ng t√¥i mang ƒë·∫øn gi·∫£i ph√°p thi·∫øt k·∫ø to√†n di·ªán cho m·ªçi nhu c·∫ßu.',
    categories: [
      {
        categoryId: 'house-normal',
        title: 'NH√Ä PH·ªê',
        projectCount: 45,
        navigationPath: '/projects/house-normal',
        displayOrder: 0
      },
      {
        categoryId: 'house-full',
        title: 'X√¢y nh√† tr·ªçn g√≥i',
        projectCount: 32,
        navigationPath: '/projects/house-full',
        displayOrder: 1
      },
      {
        categoryId: 'house-rough',
        title: 'X√¢y d·ª±ng ph·∫ßn th√¥',
        projectCount: 28,
        navigationPath: '/projects/house-rough',
        displayOrder: 2
      },
      {
        categoryId: 'house-interior',
        title: 'Thi·∫øt k·∫ø v√† thi c√¥ng n·ªôi th·∫•t',
        projectCount: 50,
        navigationPath: '/projects/house-interior',
        displayOrder: 3
      }
    ]
  }
};

// File paths
const assetsBasePath = '../../src/assets';
const imagesPath = path.join(__dirname, assetsBasePath, 'images');
const iconsPath = path.join(__dirname, assetsBasePath, 'icons');

async function initializeBucket() {
  try {
    const exists = await minioClient.bucketExists(bucketName);
    if (!exists) {
      await minioClient.makeBucket(bucketName, 'us-east-1');
      console.log(`‚úÖ Bucket '${bucketName}' created`);
    } else {
      console.log(`‚úÖ Bucket '${bucketName}' already exists`);
    }
  } catch (error) {
    console.error('‚ùå Error initializing bucket:', error);
    throw error;
  }
}

async function uploadFile(filePath, objectName) {
  try {
    if (!fs.existsSync(filePath)) {
      console.warn(`‚ö†Ô∏è  File not found: ${filePath}`);
      return `http://localhost:9000/${bucketName}/${objectName}`;
    }

    await minioClient.fPutObject(bucketName, objectName, filePath);
    const publicUrl = `http://localhost:9000/${bucketName}/${objectName}`;
    console.log(`‚úÖ Uploaded: ${path.basename(filePath)} -> ${publicUrl}`);
    return publicUrl;
  } catch (error) {
    console.error(`‚ùå Error uploading ${objectName}:`, error);
    throw error;
  }
}

async function uploadRequiredAssets() {
  const uploadedAssets = {
    images: {},
    icons: {}
  };

  console.log('üì∏ Uploading required images...');
  
  // Collect all required files from mock data
  const requiredImages = new Set();
  const requiredIcons = new Set();

  // About project image
  requiredImages.add(mockData.aboutProject.backgroundImageUrl);
  
  // Stats items images and icons
  mockData.statsSection.statsItems.forEach(item => {
    requiredImages.add(item.backgroundImageUrl);
    requiredIcons.add(item.iconUrl);
  });
  
  // Project categories images
  mockData.projectCategories.categories.forEach(category => {
    requiredImages.add(category.backgroundImageUrl);
  });

  // Upload images
  for (const imageFile of requiredImages) {
    const filePath = path.join(imagesPath, imageFile);
    const objectName = `images/${imageFile}`;
    uploadedAssets.images[imageFile] = await uploadFile(filePath, objectName);
  }

  // Upload icons
  for (const iconFile of requiredIcons) {
    const filePath = path.join(iconsPath, iconFile);
    const objectName = `icons/${iconFile}`;
    uploadedAssets.icons[iconFile] = await uploadFile(filePath, objectName);
  }

  return uploadedAssets;
}

async function seedDatabase(uploadedAssets) {
  let connection;
  
  try {
    connection = await mysql.createConnection(dbConfig);
    console.log('‚úÖ Connected to MySQL');

    // Clean up existing data
    console.log('üßπ Cleaning up existing project page data...');
    await connection.execute('DELETE FROM project_categories');
    await connection.execute('DELETE FROM project_categories_data');
    await connection.execute('DELETE FROM stats_items WHERE stats_header_id IN (SELECT id FROM stats_header WHERE main_headline LIKE "%TH√ÄNH T·ª∞U%")');
    await connection.execute('DELETE FROM stats_header WHERE main_headline LIKE "%TH√ÄNH T·ª∞U%"');
    await connection.execute('DELETE FROM about_project_data');

    // Insert About Project Data
    console.log('üìÑ Inserting About Project data...');
    const aboutImageUrl = uploadedAssets.images[mockData.aboutProject.backgroundImageUrl];
    await connection.execute(
      `INSERT INTO about_project_data (title, subtitle, background_image_url, is_active, created_at, updated_at)
       VALUES (?, ?, ?, ?, NOW(), NOW())`,
      [
        mockData.aboutProject.title,
        mockData.aboutProject.subtitle,
        aboutImageUrl,
        mockData.aboutProject.isActive
      ]
    );

    // Insert Stats Header Data (for project page stats)
    console.log('üìä Inserting Stats Header data...');
    const [statsHeaderResult] = await connection.execute(
      `INSERT INTO stats_header (main_headline, sub_headline, description, is_active, created_at, updated_at)
       VALUES (?, ?, ?, ?, NOW(), NOW())`,
      [
        mockData.statsSection.mainHeadline,
        mockData.statsSection.subHeadline,
        mockData.statsSection.description,
        true
      ]
    );

    const statsHeaderId = statsHeaderResult.insertId;

    // Insert Stats Items
    console.log('üìà Inserting Stats Items...');
    for (const item of mockData.statsSection.statsItems) {
      const backgroundImageUrl = uploadedAssets.images[item.backgroundImageUrl];
      const iconUrl = uploadedAssets.icons[item.iconUrl];
      
      await connection.execute(
        `INSERT INTO stats_items (
          stats_header_id, icon_name, icon_url, target_value, label, suffix, 
          description, background_image_url, category, display_order, is_active, created_at, updated_at
        ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, NOW(), NOW())`,
        [
          statsHeaderId,
          item.iconName,
          iconUrl,
          item.targetValue,
          item.label,
          item.suffix,
          item.description,
          backgroundImageUrl,
          item.category,
          item.displayOrder,
          true
        ]
      );
    }

    // Insert Project Categories Data
    console.log('üèóÔ∏è Inserting Project Categories data...');
    const [categoriesDataResult] = await connection.execute(
      `INSERT INTO project_categories_data (main_title, subtitle, description, is_active, created_at, updated_at)
       VALUES (?, ?, ?, ?, NOW(), NOW())`,
      [
        mockData.projectCategories.mainTitle,
        mockData.projectCategories.subtitle,
        mockData.projectCategories.description,
        true
      ]
    );

    const categoriesDataId = categoriesDataResult.insertId;

    // Insert Project Categories
    console.log('üè† Inserting Project Categories...');
    for (const category of mockData.projectCategories.categories) {
      const backgroundImageUrl = uploadedAssets.images[category.backgroundImageUrl];
      
      await connection.execute(
        `INSERT INTO project_categories (
          categories_data_id, category_id, title, project_count, background_image_url, 
          navigation_path, display_order, is_active, created_at, updated_at
        ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, NOW(), NOW())`,
        [
          categoriesDataId,
          category.categoryId,
          category.title,
          category.projectCount,
          backgroundImageUrl,
          category.navigationPath,
          category.displayOrder,
          true
        ]
      );
    }

    console.log('‚úÖ Database seeded successfully!');
    
    // Print summary
    console.log('\nüìã Seed Summary:');
    console.log(`   üìÑ About Project: 1 record`);
    console.log(`   üìä Stats Section: 1 record`);
    console.log(`   üìà Stats Items: ${mockData.statsSection.statsItems.length} records`);
    console.log(`   üèóÔ∏è Project Categories Data: 1 record`);
    console.log(`   üè† Project Categories: ${mockData.projectCategories.categories.length} records`);
    
  } catch (error) {
    console.error('‚ùå Error seeding database:', error);
    throw error;
  } finally {
    if (connection) {
      await connection.end();
    }
  }
}

async function main() {
  try {
    console.log('üöÄ Starting Project Page seeding from mock data...');
    console.log('üìÇ Assets path:', assetsBasePath);
    
    // Check if assets folders exist
    if (!fs.existsSync(imagesPath)) {
      console.error(`‚ùå Images folder not found: ${imagesPath}`);
      process.exit(1);
    }
    
    if (!fs.existsSync(iconsPath)) {
      console.error(`‚ùå Icons folder not found: ${iconsPath}`);
      process.exit(1);
    }
    
    // Initialize MinIO bucket
    await initializeBucket();
    
    // Upload required assets
    const uploadedAssets = await uploadRequiredAssets();
    
    // Seed database
    await seedDatabase(uploadedAssets);
    
    console.log('üéâ Project Page seeding completed successfully!');
    console.log('üîó You can now access the seeded data via the API endpoints');
    console.log('   üìÑ GET /api/v1/projectpage/about-project');
    console.log('   üìä GET /api/v1/projectpage/stats-section');
    console.log('   üèóÔ∏è GET /api/v1/projectpage/project-categories');
    console.log('   üåê GET /api/v1/projectpage (all data)');
    
  } catch (error) {
    console.error('üí• Seeding process failed:', error);
    process.exit(1);
  }
}

// Add this script to package.json scripts
console.log('üí° To add this to your package.json scripts:');
console.log('   "seed:project-page": "node scripts/seedProjectPageFromMock.js"');

main(); 